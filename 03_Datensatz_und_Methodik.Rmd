
## Selektion des Datensatzes

Der zur Verfügung stehende Datensatz enthielt Daten über 979 Fonds für den Zeitraum 01/1990-08/2020.

Im Einklang mit den Studien von @Koh.2003, @Agarwal.2004 sowie @Ammann.2005 enthält der in dieser Studie analysierte Datensatz sowohl durchgängig laufende Fonds, als auch solche die im betrachteten Zeitraum die Geschäftstätigkeit eingestellt haben. Dadurch kann der survivorship bias verhindert werden, also eine Überschätzung der Rendite aufgrund der fehlenden Berücksichtigung eingestellter Fonds.^[zum survivorship bias siehe u.a. @Brown.1992 oder @Elton.1996]

Hinsichtlich der weiteren Bereinigung des Datensatzes haben beispielsweise @Jones.2007, @Ammann.2005 sogenannte 'Funds of Funds (FoF)' aus der Analyse ausgeschlossen. Um eine potentielle Verzerrung der Ergebnisse zu vermeiden, folgt die vorliegende Studie diesem Ansatz und berücksichtigt in der Analyse keine FoF.


<!--Laden der benötigten Packages-->
```{r loading packages, include=FALSE, warning= FALSE}

library(tidyverse)
library(tinytex)
library(broom)
library(viridis) # für color-schemes
library(DescTools) # Zum Durchführen des Jarque-Bera Tests auf Normalverteilung der Returns
library(knitr)


```


<!--Laden der Informationen zu den einzelnen Hedgefunds-->
```{r base_data, include=FALSE, warning= FALSE}

base_data <- read_csv("./DATA/basedata.csv") %>%
  filter(`Morningstar Category` != "HF Fund of Funds - Equity") %>%
  select(`name`, `secid`, `Inception Date`, `Obsolete Date`, `Status`, `Net Assets Date`,
         `Net Assets - Share Class USD`, `Fund Size Date`, `Fund Size USD`)

base_data_age <- base_data %>%
  filter(`Inception Date` <= "2005-01-01") %>% #Nur Fonds die vor/am 2005-01-01 gegründet wurden
  mutate(age_y = as.numeric(round((as.Date("2005-01-01") - `Inception Date`)/365))) %>% #Berechnung Alter
  mutate(age_class = case_when(                # Erstellung der Altersklassen
    age_y < 2 ~ "young",
    age_y >= 2 & age_y <=4 ~ "medium",
    age_y > 4 ~ "old")) %>%
  arrange(secid, .by_group = FALSE) %>%
  select(`name`, `secid`, `age_y`, `age_class`)

base_data_size <- base_data %>%
  mutate(`size` = coalesce(`Fund Size USD`, `Net Assets - Share Class USD`)) %>% # Gemergte Variable 'size'
  mutate(`size_date` = coalesce(`Fund Size Date`, `Net Assets Date`)) %>% # Gemergte Variable 'size date'
  filter(`size` >= 1000000 & `size_date` >= "2010-01-01") %>% # Nur Fonds mit Mindestgröße & akt. Size-Date
  arrange(secid, .by_group = FALSE) %>%
  select(`name`, `secid`, `size`)


```


<!--Laden der Faktor-Daten-->
```{r factor_data, include=FALSE, warning= FALSE}

factor_data <- read_csv("./DATA/factordata.csv",
    col_types = cols(
    date = col_date(format = "%d%.%m%.%Y"))) %>%
    select(date, mktrf, smb, hml, umd, rf)

factor_data_age <- factor_data %>%
  filter(date >= "2005-01-01" & date < "2015-01-01") # Einschränken auf den Zeitraum 01/2005-01/2015

factor_data_size <- factor_data %>%
  filter(date >= "2010-01-01") # Einschränken auf den Zeitraum 01/2010-08/2020


# mktrf = market reference
# smb = Size factor; small-minus-big
# hml = Value factor; high-minus-low
# rmw = robust-minus-weak
# cma = conservative-minus-aggressive
# rf = risk free rate
# umd = Momentum factor; up-minus-down

```


<!--Laden des raw_data Datensatzes-->
```{r raw_data, include=FALSE, warning= FALSE}

raw_data <- read_csv("./DATA/mri.csv",
                    col_types = cols(
                    date = col_date(format = "%d%.%m%.%Y")))

raw_data_age <- raw_data %>%
  filter(date >= "2005-01-01" & date <= "2015-01-01") %>%# Einschränken auf den Zeitraum 01/2005-12/2015
  keep(~ (sum(. >= 0) / length(.)) >= 0.5)

raw_data_age[,2:715][raw_data_age[,2:715] == "-NA"] <- NA


raw_data_size <- raw_data %>%
  filter(date >= "2010-01-01") %>% # Einschränken auf den Zeitraum 01/2010-08/2020
  keep(~ (sum(. >= 0) / length(.)) >= 0.5)               

raw_data_size[,2:309][raw_data_size[,2:309] == "-NA"] <- NA


```


<!--Eingrenzen von raw_data entsprechend der Selektion in base_data-->
```{r, include=FALSE, warning= FALSE}

# Für Age:

list_age <- base_data_age$secid %>%    # Liste mit Fonds, die für die Stichprobe "Age" aus dem base_data
  c(., "date")                         # Datensatz gefiltert wurden

raw_data_age_funds <- raw_data_age %>% # Erstellen eines Subsets von raw_data, welches nur die Fonds aus
  select(any_of(list_age)) %>%         # der zuvor erstellten Age-Liste enthält
  relocate(date)


# Für Size:

list_size <- base_data_size$secid %>%    # Liste mit Fonds, die für die Stichprobe "Size" aus dem base_data
  c(., "date")                           # Datensatz gefiltert wurden

raw_data_size_funds <- raw_data_size %>% # Erstellen eines Subsets von raw_data, welches nur die Fonds aus
  select(any_of(list_size)) %>%          # der zuvor erstellten Size-Liste enthält
  relocate(date)

```


<!--Aufräumen (tidy) und Return-Berechnung von beiden raw_data Datensätzen-->
```{r, include=FALSE, warning= FALSE}

# Für Age:

raw_data_age_funds$FHUSA04B6U <- as.character(raw_data_age_funds$FHUSA04B6U)
raw_data_age_funds$F00000GUU3 <- as.character(raw_data_age_funds$F00000GUU3)

tidy_return_age <- raw_data_age_funds %>%
      pivot_longer(cols = !date,
      names_to = "secid",
      values_to = "prc")

tidy_return_age$prc <- as.numeric(tidy_return_age$prc)

tidy_return_age <- tidy_return_age %>%
      group_by(secid) %>%
      mutate(ret = prc/lag(prc, n = 1)-1) %>%
      ungroup() %>%
      arrange(secid, date) %>%
      filter(!is.na(prc))


# Für Size:

raw_data_size_funds$FHUSA04B6U <- as.character(raw_data_size_funds$FHUSA04B6U)
raw_data_size_funds$F00000GUU3 <- as.character(raw_data_size_funds$F00000GUU3)

tidy_return_size <- raw_data_size_funds %>%
      pivot_longer(cols = !date,
      names_to = "secid",
      values_to = "prc")

tidy_return_size$prc <- as.numeric(tidy_return_size$prc)

tidy_return_size <- tidy_return_size %>%
      group_by(secid) %>%
      mutate(ret = prc/lag(prc, n = 1)-1) %>%
      ungroup() %>%
      arrange(secid, date) %>%
      filter(!is.na(prc))


```


<!--Durchführen des Jarque-Bera Tests auf Normalverteilung der Returns für Alter-->
```{r, include=FALSE, warning=FALSE}

# Für Age:
#DescTools::JarqueBeraTest(x = tidy_return_age$ret,
#                          robust = TRUE,
#                          method = c("chisq", "mc"),
#                          N = 0,
#                          na.rm = TRUE)

```  

<!--Durchführen des Jarque-Bera Tests auf Normalverteilung der Returns für Größe-->
```{r, include=FALSE, warning= FALSE}

# Für Size:
#DescTools::JarqueBeraTest(x = tidy_return_size$ret,
#                          robust = FALSE,
#                          method = c("chisq", "mc"),
#                          N = 0,
#                          na.rm = TRUE)


```


Um das Testen von Hypothesen betreffend der Modell-Parameter durchführen zu können, muss zunächst die Annahme der Normalverteilung geprüft werden [@Brooks.2019, S. 209]. Hierfür eignet sich beispielsweise der bekannte Jarque-Bera-Test.^[@Jarque.1980, @Jarque.1987] Dieser wurde daher auf beide Datensätze angewandt und kommt zu dem Ergebnis, dass hinsichtlich der betrachteten Renditen die Verteilung statistisch signifikant von der Normalverteilung abweicht. Allerdings haben analytische Tests auf Normalverteilung, wie bspw. auch der Kolmogorov-Smirnov Test oder der Shapiro-Wilk Test, die Eigenschaft, bei sehr kleinen Stichproben eine geringe Power und bei sehr großen Stichproben einen automatisch signifikanten p-Wert aufzuweisen.^[siehe bspw. @AldorNoiman.2013, @Field.2018] Aufgrunddessen wird ein weiterer, optischer Test auf Normalverteilung anhand von Histogrammen vorgenommen, die die Verteilung der Renditen beider Stichproben darstellen:

<!--Histogramm zur Prüfung auf Normalverteilung der Returns für Alter-->
```{r echo=FALSE, warning=FALSE}


# Für Age:

ggplot(data = tidy_return_age, aes(x=ret)) +
  geom_histogram(aes(y =..density..),fill="#440154FF",alpha=0.95,binwidth = 0.001)+theme_minimal()+
scale_x_continuous(limits =c(-0.4,0.4))+ 
stat_function(fun = dnorm,args = list(mean = mean(tidy_return_age$ret, na.rm = TRUE), sd = sd(tidy_return_age$ret, na.rm = TRUE)),aes(colour = "normal distribution"), size=0.7)+
geom_density(aes(color="distribution for age"),size=0.7)+ scale_colour_manual("distributions", values = c("#287D8EFF","#FDE725FF"))

```  

<!--Histogramm zur Prüfung auf Normalverteilung der Returns für Größe-->
```{r, echo=FALSE, warning= FALSE}

# Für Size:

ggplot(data = tidy_return_size, aes(x=ret)) +
  geom_histogram(aes(y =..density..),fill="#440154FF",alpha=0.95,binwidth = 0.001)+theme_minimal()+
scale_x_continuous(limits =c(-0.4,0.4))+ 
stat_function(fun = dnorm,args = list(mean = mean(tidy_return_age$ret, na.rm = TRUE), sd = sd(tidy_return_age$ret, na.rm = TRUE)),aes(colour = "normal distribution"), size=0.7)+
geom_density(aes(color="distribution for size"),size=0.7)+ scale_colour_manual("distributions", values = c("#287D8EFF","#FDE725FF"))

```
Erläuterung Histogramme


<!--Mergen von tidy_data und factor_data-->
```{r, include=FALSE, warning= FALSE}

# Für Age:
final_data_age <- left_join(tidy_return_age, factor_data_age, by = "date") %>%
      mutate(retrf = ret - rf)

# Für Size:
final_data_size <- left_join(tidy_return_size, factor_data_size, by = "date") %>%
      mutate(retrf = ret - rf)


```


<!--IR und SR in einem Schritt für Age-->
```{r, include=FALSE, warning= FALSE}

alphas_final_age <- final_data_age %>%
  group_by(secid) %>%
  do(tidy(lm(retrf~mktrf, data = .)))  %>% 
  filter(term == "(Intercept)") %>% 
  select(secid, estimate) %>% 
  rename(alpha = estimate)


summary_final_age <- final_data_age %>%
  group_by(secid) %>%
  do(augment(lm(retrf~mktrf, data = .)))  %>% 
  summarise(idiosyncratic_risk = sd(.resid, na.rm = TRUE), #.resid sind die Residuale
            mean = 12*mean(retrf, na.rm = TRUE),
            volatility = sqrt(12)*sd(retrf, na.rm = TRUE),
            sr = mean/volatility) %>%
  left_join(alphas_final_age, by = "secid") %>% # Hinzufügen der Alphas zum Datensatz
  mutate(ir = sqrt(12)*alpha/idiosyncratic_risk,
         alpha = 12*alpha) %>% 
  left_join(base_data_age, by = "secid") %>%  # Hinzufügen der Variablen Name, Alter und Alters-Klasse
  select(name, secid, mean, volatility, sr, alpha, ir, age_y, age_class)

# Pi: hier könnte man auch noch die Sortino Ratio mit aufnehmen

```


<!--IR und SR in einem Schritt für Size-->
```{r, include=FALSE, warning= FALSE}

alphas_final_size <- final_data_size %>%
  group_by(secid) %>%
  do(tidy(lm(retrf~mktrf, data = .)))  %>% 
  filter(term == "(Intercept)") %>% 
  select(secid, estimate) %>% 
  rename(alpha = estimate)


summary_final_size <- final_data_size %>%
  group_by(secid) %>%
  do(augment(lm(retrf~mktrf, data = .)))  %>% 
  summarise(idiosyncratic_risk = sd(.resid, na.rm = TRUE), #.resid sind die Residuale
            mean = 12*mean(retrf, na.rm = TRUE),
            volatility = sqrt(12)*sd(retrf, na.rm = TRUE),
            sr = mean/volatility) %>% 
  left_join(alphas_final_size, by = "secid") %>% # Hinzufügen der Alphas zum Datensatz
  mutate(ir = sqrt(12)*alpha/idiosyncratic_risk,
         alpha = 12*alpha) %>%
  left_join(base_data_size, by = "secid") %>%  # Hinzufügen der Variablen Name, Alter und Alters-Klasse
  mutate(Quantile_Class = ntile(`size`, 5)) %>%
  mutate(Class_Jones= case_when(`size`
 <= 100000000 ~ "small", `size` > 100000000  & `size` <= 500000000 ~ "medium", `size` > 500000000 ~ "big"))%>%              # Einstufung nach Klassen nach Jones
  select(name, secid, mean, volatility, sr, alpha, ir, size, Quantile_Class, Class_Jones)

```
Zuerst müssen die Daten aus dem datensatz "Basedata" geladen und die benötigten Variablen ausgesucht werden.
Um Altersvergleiche zu bestimmen, müssen das Alter bzw. die Lebensspanne der funds bestimmt werden.Als Alter wird das Alter zum Beginn des Intervalls verwendet.
Im Anschluss wird ein Zeitintervall für die Analyse bestimmt. In der vorliegenden Analyse werden nur Funds, die vor 2005 gegründet wurden, untersucht. Für einige Funds wird kein Obsolete Date aufgeführt. Da aber häufig Ablesedaten für die size aufgeführt werden, wird für alle NAs das Ablesedatum der Größe eingefügt. Liegt dieses ebenfalls nicht vor, werden diese Funds nicht berücksichtigt.
Um Größenvergleiche durchzuführen,werden aus dem Set alle Funds mit einem Wert für size oder Net Asset Value von unter einer Million USD gelöscht. Im Anschluss wird das Interval für alle Funds aktiv ab 2010 gebildet und die Klasseneinteilung nach Jones(2007) vorgenommen.
Im Anschluss wurden die weiteren Datensätze eingearbeitet und benannt. Zuerst der mri für den Zeitraum 2005-2015 zur Analyse des Alters und für 2010-2020 für die Größe.

```{r, include=FALSE, warning= FALSE}

#sortieren nach Klassen
summary_final_age <- summary_final_age%>%
  arrange(match(age_class, c("young", "medium", "old")))

#Festlegung Reihenfolge für plots
summary_final_age$age_class <- factor(summary_final_age$age_class, levels = c("young", "medium", "old"))

#plot mit viridis
ggplot(summary_final_age)+geom_bar(aes(x=age_class,y = ..prop.., group = 1), stat = "count", fill=(values=viridis(3)))+ scale_y_continuous(labels = scales::percent_format()) + theme_minimal()

```

Nach Filtern und Bestimmen der Klassen mit den Größen jung als unter zwei Jahre, medium als zwischen zwei und vier und alt als alle funds über vier ergibt sich die in Figure () dargestellte Verteilung. Insgesamt werden ... Funds berücksichtigt. Auch wenn alte Funds mit einer Anzahl von ... ca. ...% der Verteilung stellen, ist die Anzahl für junge () und mittlere () Funds ausreichend groß für eine weitere Analyse. Hier folgt die Arbeit der Einteilung von Jones(2007).

```{r, include=FALSE, warning= FALSE}

#sortieren nach Klassen
summary_final_size <- summary_final_size%>%
  arrange(match(Class_Jones, c("small", "medium", "big")))

#Festlegung Reihenfolge für plots
summary_final_size$Class_Jones <- factor(summary_final_size$Class_Jones, levels = c("small", "medium", "big"))

#plot mit viridis
ggplot(summary_final_size)+geom_bar(aes(x=Class_Jones,y = ..prop.., group = 1), stat = "count", fill=(values=viridis(3)))+ scale_y_continuous(labels = scales::percent_format()) + theme_minimal()

```


Die Darstellung der Verteilung mit Klassenbildung nach Jones zeigt eine klare Verzerrung hin zu kleinen Funds. So bilden die kleinen Funds mit ... Vertretern ca. ...% der Verteilung, während große Funds mit ...% unterrepräsentiert sind. Somit ist keine Analyse für Funds ausserhalb der Kategorie klein gegeben.

Um dem gerecht zu werden, wird ein anderer Ansatz, die Einteilung in "20% Centile" vorgenommen.

## Deskriptive Statistik

Zuerst werden Kennziffern für gesamten Datensätze bestimmt.\\

Im Anschluss werden die gleichen Kennziffern für die drei Klassen für Alter bestimmt. Um Altersvergleiche zu bestimmen, müssen das Alter bzw. die Lebensspanne der funds bestimmt werden.Als Alter wird das Alter zum Beginn des Intervalls verwendet.


```{r, include=FALSE, warning= FALSE}

#zum Spass: kleine darstellung für alle Funds bei Age, white noise

ggplot(data=tidy_return_age) + aes(x=date, y = ret) + geom_line()

```

Eine einfache Darstellung der returns ist nicht hilfreich, erst nach Klassifizierung und Bearbeitung der Daten ergeben sich die Zusammenhänge.

```{r, warning= FALSE}

# plot aller funds mit mean und volatility, sortiert nach Klassen für Alter mit summary_final_age


ggplot(summary_final_age,
  aes(x=mean, y=volatility, color=age_class)) +
  geom_point(size=1.75, alpha=0.8)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

```

```{r, include=FALSE, warning= FALSE}

# plot aller funds mit mean und volatility, sortiert nach Klassen für Size mit summary_final_size

summary_final_size$Quantile_Class <- factor(summary_final_size$Quantile_Class, levels = c("1", "2", "3","4","5"))

ggplot(summary_final_size,
  aes(x=mean, y=volatility, color=Quantile_Class)) +
  geom_point(size=1.75, alpha=0.8)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

```


```{r, include=FALSE, warning= FALSE}

#Summary für alles nach Klassen für Alter
#Erstellen der einzelnen Zusammenfassungen für die Klassen
class_young <- summary_final_age%>%
  filter(age_class=="young")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="young")%>%
  relocate(class, .before = mean_c)

class_medium_age <- summary_final_age%>%
  filter(age_class=="medium")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="medium")%>%
  relocate(class, .before = mean_c)

class_old <- summary_final_age%>%
  filter(age_class=="old")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="old")%>%
  relocate(class, .before = mean_c)

#Zusammenfassen in einer summary

class_summary_final_age <- bind_rows(class_young,class_medium_age,class_old, .id = "age_class")%>%
  mutate(class= c("young","medium","old"))%>%
  select(2:7)

```

```{r, include=FALSE, warning= FALSE}

#Erstellen der einzelnen Zusammenfassungen für die Klassen bei Size mit Quantilen

class_01 <- summary_final_size%>%
  filter(Quantile_Class=="1")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="1")%>%
  relocate(class, .before = mean_c)

class_02 <- summary_final_size%>%
  filter(Quantile_Class=="2")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="2")%>%
  relocate(class, .before = mean_c)

class_03 <- summary_final_size%>%
  filter(Quantile_Class=="3")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="3")%>%
  relocate(class, .before = mean_c)

class_04 <- summary_final_size%>%
  filter(Quantile_Class=="4")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="4")%>%
  relocate(class, .before = mean_c)

class_05 <- summary_final_size%>%
  filter(Quantile_Class=="5")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="5")%>%
  relocate(class, .before = mean_c)


#Zusammenfassen in einer summary

class_summary_final_size <- bind_rows(class_01,class_02,class_03,class_04,class_05, .id = "age_class")%>%
  mutate(class= c("1","2","3","4","5"))%>%
  select(2:7)

```

```{r, include=FALSE, warning= FALSE}

#Summary für alles nach Klassen für Size nach Jones
#Erstellen der einzelnen Zusammenfassungen für die Klassen

class_small <- summary_final_size%>%
  filter(Class_Jones=="small")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="small")%>%
  relocate(class, .before = mean_c)

class_medium_size <- summary_final_size%>%
  filter(Class_Jones=="medium")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="medium")%>%
  relocate(class, .before = mean_c)


class_big <- summary_final_size%>%
  filter(Class_Jones=="big")%>%
  summarise(mean_c = mean(mean),
            volatility_c = mean(volatility),
            sr_c = mean(sr),
            ir_c=mean(ir),
            alpha_c=mean(alpha))%>%
  mutate(class="big")%>%
  relocate(class, .before = mean_c)

#Zusammenfassen in einer summary

class_summary_final_size_jones <- bind_rows(class_small,class_medium_size,class_big, .id = "age_class")%>%
  mutate(class= c("small","medium","big"))%>%
  select(2:7)

```

```{r, include=FALSE, warning= FALSE}

#Darstellung Zshg. Volatility/Mean für Alter nur der drei Klassen class_summary_final_age

class_summary_final_age$class <- factor(class_summary_final_age$class, levels = c("young", "medium", "old"))

ggplot(class_summary_final_age,
  aes(x=mean_c, y=volatility_c, color=class)) +
  geom_point(size=3, alpha=1)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

```

```{r, include=FALSE, warning= FALSE}

#Darstellung Zshg. Volatility/Mean für Size nur der fünf Klassen

class_summary_final_size$class <- factor(class_summary_final_size$class, levels = c("1", "2", "3","4","5"))

ggplot(class_summary_final_size,
  aes(x=mean_c, y=volatility_c, color=class)) +
  geom_point(size=3, alpha=1)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

```

```{r, warning= FALSE}

#Darstellung Zshg. Volatility/Mean für Size nur der drei Klassen 

class_summary_final_size_jones$class <- factor(class_summary_final_size_jones$class, levels = c("small", "medium", "big"))

ggplot(class_summary_final_size_jones,
  aes(x=mean_c, y=volatility_c, color=class)) +
  geom_point(size=3, alpha=1)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

```

```{r}
#density für sharpe ratios bei alter

ggplot(data=summary_final_age, aes(x=sr, group=age_class, fill=age_class)) +
    geom_density(adjust=0.8, alpha=0.75) + scale_fill_viridis(discrete=TRUE) +
    scale_color_viridis(discrete=TRUE) +
    theme_minimal()

#values = c("#287D8EFF","#FDE725FF"))

```
```{r}
#density für sharpe ratios bei size mit 5 Klassen

ggplot(data=summary_final_size, aes(x=sr, group=Quantile_Class, fill=Quantile_Class)) +
    geom_density(adjust=0.8, alpha=0.75) + scale_fill_viridis(discrete=TRUE) +
    scale_color_viridis(discrete=TRUE) +
    theme_minimal()
```
```{r}
#density für information ratio bei size


ggplot(data=summary_final_size, aes(x=ir, group=Quantile_Class, fill=Quantile_Class)) +
    geom_density(adjust=0.8, alpha=0.75) + scale_fill_viridis(discrete=TRUE) +
    scale_color_viridis(discrete=TRUE) +
    theme_minimal()
```
```{r}
#density für information ratio bei age


ggplot(data=summary_final_age, aes(x=ir, group=age_class, fill=age_class)) +
    geom_density(adjust=0.8, alpha=0.75) + scale_fill_viridis(discrete=TRUE) +
    scale_color_viridis(discrete=TRUE) +
    theme_minimal()
```

```{r}

#plots von mean und vola und sr nach altersgruppen plus alle zusammen

y <- ggplot(data=summary_final_age[summary_final_age$age_y < 2,]) + aes(x=volatility, y = mean, color=sr)+ geom_point(size=1.75, alpha=0.8) +scale_color_viridis(discrete=FALSE, option="viridis")+ theme_minimal()+ geom_smooth(method=lm , color="#440154FF", se=FALSE)

m <- ggplot(data=summary_final_age[summary_final_age$age_y <= 2 & summary_final_age$age_y <= 4,]) + aes(x=volatility, y = mean, color=sr)+ geom_point(size=1.75, alpha=0.8) +scale_color_viridis(discrete=FALSE, option="viridis")+ theme_minimal()+ geom_smooth(method=lm , color="#440154FF", se=FALSE)
  
o <- ggplot(data=summary_final_age[summary_final_age$age_y > 4 ,]) + aes(x=volatility, y = mean, color=sr)+ geom_point(size=1.75, alpha=0.8) +scale_color_viridis(discrete=FALSE, option="viridis")+ theme_minimal()+ geom_smooth(method=lm , color="#440154FF", se=FALSE)

a <- ggplot(summary_final_age,
  aes(x=volatility, y=mean, color=age_class)) +
  geom_point(size=1.75, alpha=0.8)+scale_color_viridis(discrete=TRUE, option="viridis")+ theme_minimal()

library(gridExtra)
grid.arrange(y, m, o, a, ncol=2, nrow=2)
```




## Performancemaße

Hier werden die genutzten Performancemaße vorgestellt.

\newpage